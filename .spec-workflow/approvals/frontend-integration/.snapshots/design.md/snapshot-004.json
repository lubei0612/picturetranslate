{
  "id": "snapshot_1764839614562_bz2n9gzx9",
  "approvalId": "approval_1764837946795_7j4ts6zkd",
  "approvalTitle": "Design V2: SQLite全栈架构 + 批量/Mask/历史/H5",
  "version": 4,
  "timestamp": "2025-12-04T09:13:34.562Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: 图片翻译系统升级\n\n## Overview\n\n基于方案 A（轻量级 SQLite 全栈）实现图片翻译系统升级，支持 100 用户（10 并发）。核心特性：批量翻译、Mask 区域选择、文字编辑、历史记录、H5 响应式。\n\n**Codex 审查修订版本**: v2.0 (2024-12-04)\n\n## Steering Document Alignment\n\n### Technical Standards\n- 后端：FastAPI 分层架构（api/services/core/utils）\n- 前端：React 19 + TypeScript + Tailwind CSS\n- 存储：文件系统 + SQLite 路径索引\n- 部署：Dokploy Docker 单容器\n\n### Project Structure\n```\npicturetranslate/\n├── api/                    # FastAPI 路由层\n│   ├── routes/\n│   │   ├── translate.py    # 翻译 API（升级）\n│   │   ├── jobs.py         # 批量任务 API（新增）\n│   │   ├── history.py      # 历史记录 API（新增）\n│   │   └── health.py\n│   └── dependencies.py\n├── services/               # 业务逻辑层\n│   ├── translator.py       # 翻译服务（升级）\n│   ├── job_queue.py        # 任务队列服务（新增）\n│   ├── storage.py          # 文件存储服务（新增）\n│   ├── history.py          # 历史管理服务（新增）\n│   ├── cleanup.py          # 定时清理服务（新增）\n│   └── sse_manager.py      # SSE 事件管理（新增）\n├── core/\n│   ├── config.py\n│   ├── database.py         # SQLite 连接池（新增）\n│   ├── sentry.py           # Sentry 初始化（新增）\n│   └── exceptions.py\n├── models/                 # 数据模型（新增）\n│   ├── job.py\n│   └── translation.py\n├── frontend/src/\n│   ├── components/\n│   │   ├── Dashboard.tsx   # 升级：批量上传\n│   │   ├── Editor.tsx      # 升级：Mask + TextLayer\n│   │   ├── MaskCanvas.tsx  # 新增：画笔组件\n│   │   ├── TextEditor.tsx  # 新增：文字编辑\n│   │   └── History.tsx     # 新增：历史页面\n│   ├── hooks/\n│   │   ├── useTranslation.ts\n│   │   ├── useJobQueue.ts  # 新增：任务队列\n│   │   └── useHistory.ts   # 新增：历史记录\n│   ├── api/\n│   │   └── client.ts       # 升级：新 API\n│   └── sentry.ts           # Sentry React 初始化（新增）\n└── storage/                # 文件存储目录（新增）\n    └── {job_id}/\n        └── {image_uuid}/   # 每张图片独立目录\n            ├── original.png\n            ├── mask.webp\n            └── result.png\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **processor.py**: 核心翻译逻辑保持不变\n- **services/translator.py**: 升级支持 Mask 参数\n- **services/cache.py**: LRU 缓存继续使用\n- **utils/image.py**: 图片验证复用\n- **utils/retry.py**: 重试装饰器复用\n- **frontend/api/translateClient.ts**: 升级为多 API 支持\n\n### Integration Points\n- **Aliyun API**: 继续使用现有集成\n- **Docker**: 升级 Dockerfile 添加 Volume\n- **Sentry**: 新增集成\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│  Frontend (React + Tailwind)                                    │\n│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐            │\n│  │  Dashboard   │ │    Editor    │ │   History    │            │\n│  │  - 批量上传   │ │  - MaskCanvas│ │  - 列表筛选   │            │\n│  │  - 进度显示   │ │  - TextEditor│ │  - 预览下载   │            │\n│  │  - 响应式    │ │  - Split View│ │              │            │\n│  └──────────────┘ └──────────────┘ └──────────────┘            │\n│         │                │                │                     │\n│  ┌──────────────────────────────────────────────────┐          │\n│  │  Hooks: useTranslation, useJobQueue, useHistory  │          │\n│  └──────────────────────────────────────────────────┘          │\n└─────────────────────────────────────────────────────────────────┘\n                              │\n                    REST API + SSE\n                              ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  FastAPI Backend                                                │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │  Routes                                                  │   │\n│  │  POST /api/jobs           创建批量任务                    │   │\n│  │  GET  /api/jobs/{id}      获取任务状态                    │   │\n│  │  GET  /api/jobs/{id}/sse  SSE 进度推送                    │   │\n│  │  GET  /api/history        历史列表                        │   │\n│  │  GET  /api/history/{id}   历史详情                        │   │\n│  │  DELETE /api/history/{id} 删除记录                        │   │\n│  │  GET  /health             健康检查                        │   │\n│  └─────────────────────────────────────────────────────────┘   │\n│                              │                                  │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │  Services                                                │   │\n│  │  ├─ JobQueueService      SQLite 状态机队列               │   │\n│  │  ├─ TranslatorService    翻译执行 + Mask 支持            │   │\n│  │  ├─ StorageService       文件存储 + 路径管理             │   │\n│  │  ├─ HistoryService       历史 CRUD                       │   │\n│  │  └─ CleanupService       90天定时清理                    │   │\n│  └─────────────────────────────────────────────────────────┘   │\n│                              │                                  │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │  Data Layer                                              │   │\n│  │  ├─ SQLite (translations.db)                            │   │\n│  │  │   ├─ jobs (id, status, created_at, images_count)     │   │\n│  │  │   ├─ translations (id, job_id, paths, params, ...)   │   │\n│  │  │   └─ cleanup_log (id, deleted_at, count)             │   │\n│  │  └─ File Storage (./storage/)                           │   │\n│  │      └─ {job_id}/original.png, mask.webp, result.png    │   │\n│  └─────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Components and Interfaces\n\n### Backend Components\n\n#### 1. JobQueueService (services/job_queue.py)\n- **Purpose**: SQLite 状态机队列管理\n- **Interfaces**:\n  ```python\n  create_job(images: List[UploadFile], params: TranslateParams) -> Job\n  get_job(job_id: str) -> Job\n  update_status(job_id: str, status: JobStatus) -> None\n  get_pending_jobs() -> List[Job]\n  ```\n- **Dependencies**: SQLite, StorageService\n- **状态流**: pending → processing → done/failed\n\n#### 2. StorageService (services/storage.py)\n- **Purpose**: 文件存储和路径管理（支持批量图片）\n- **Interfaces**:\n  ```python\n  save_original(job_id: str, image_uuid: str, image: bytes) -> str\n  save_mask(job_id: str, image_uuid: str, mask: bytes, mime_type: str) -> str\n  save_result(job_id: str, image_uuid: str, result: bytes) -> str\n  get_file(path: str) -> bytes\n  delete_job_files(job_id: str) -> None\n  ```\n- **Dependencies**: 文件系统\n- **路径格式**: `./storage/{job_id}/{image_uuid}/{filename}`\n\n#### StorageService 实现示例\n\n```python\nimport os\nimport uuid\nfrom pathlib import Path\nfrom PIL import Image\nimport io\n\nclass StorageService:\n    def __init__(self, base_path: str = \"./storage\"):\n        self.base_path = Path(base_path)\n        self.base_path.mkdir(parents=True, exist_ok=True)\n    \n    def _get_image_dir(self, job_id: str, image_uuid: str) -> Path:\n        \"\"\"获取图片存储目录：storage/{job_id}/{image_uuid}/\"\"\"\n        path = self.base_path / job_id / image_uuid\n        path.mkdir(parents=True, exist_ok=True)\n        return path\n    \n    def save_original(self, job_id: str, image_uuid: str, image: bytes) -> str:\n        \"\"\"保存原图\"\"\"\n        dir_path = self._get_image_dir(job_id, image_uuid)\n        file_path = dir_path / \"original.png\"\n        file_path.write_bytes(image)\n        return str(file_path.relative_to(self.base_path))\n    \n    def save_mask(self, job_id: str, image_uuid: str, mask: bytes, mime_type: str) -> str:\n        \"\"\"\n        保存 Mask 图片\n        - 验证 MIME 类型\n        - WebP/PNG 直接保存，其他格式转 PNG\n        \"\"\"\n        allowed_types = {\"image/webp\", \"image/png\"}\n        if mime_type not in allowed_types:\n            # 不支持的格式，转换为 PNG\n            img = Image.open(io.BytesIO(mask))\n            buffer = io.BytesIO()\n            img.save(buffer, format=\"PNG\")\n            mask = buffer.getvalue()\n            ext = \"png\"\n        else:\n            ext = \"webp\" if mime_type == \"image/webp\" else \"png\"\n        \n        dir_path = self._get_image_dir(job_id, image_uuid)\n        file_path = dir_path / f\"mask.{ext}\"\n        file_path.write_bytes(mask)\n        return str(file_path.relative_to(self.base_path))\n    \n    def delete_job_files(self, job_id: str) -> None:\n        \"\"\"删除整个任务的所有文件\"\"\"\n        import shutil\n        job_path = self.base_path / job_id\n        if job_path.exists():\n            shutil.rmtree(job_path)\n```\n\n#### 3. HistoryService (services/history.py)\n- **Purpose**: 历史记录 CRUD\n- **Interfaces**:\n  ```python\n  list_history(page: int, limit: int, filters: dict) -> List[Translation]\n  get_history(id: str) -> Translation\n  delete_history(id: str) -> None\n  ```\n- **Dependencies**: SQLite\n\n#### 4. CleanupService (services/cleanup.py)\n- **Purpose**: 90 天自动清理\n- **Interfaces**:\n  ```python\n  schedule_cleanup() -> None  # APScheduler 每日 3:00\n  run_cleanup() -> int        # 返回删除数量\n  ```\n- **Dependencies**: SQLite, StorageService, APScheduler\n\n#### CleanupService 实现（单实例保证 + misfire 处理）\n\n```python\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore\nfrom apscheduler.executors.pool import ThreadPoolExecutor\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass CleanupService:\n    def __init__(self, db_url: str, storage_service: StorageService):\n        self.storage = storage_service\n        self.db_url = db_url\n        self.scheduler: Optional[AsyncIOScheduler] = None\n    \n    def schedule_cleanup(self):\n        \"\"\"\n        配置 APScheduler：\n        - SQLite JobStore 保证任务持久化和单实例\n        - misfire_grace_time: 错过执行窗口后仍执行（最多延迟1小时）\n        - coalesce: 合并错过的多次执行为一次\n        \"\"\"\n        jobstores = {\n            'default': SQLAlchemyJobStore(url=self.db_url)\n        }\n        executors = {\n            'default': ThreadPoolExecutor(1)  # 单线程执行清理\n        }\n        job_defaults = {\n            'coalesce': True,           # 错过多次只执行一次\n            'max_instances': 1,          # 同一任务最多一个实例\n            'misfire_grace_time': 3600,  # 1小时内仍可执行\n        }\n        \n        self.scheduler = AsyncIOScheduler(\n            jobstores=jobstores,\n            executors=executors,\n            job_defaults=job_defaults,\n            timezone='Asia/Shanghai'\n        )\n        \n        # 每天凌晨 3:00 执行清理\n        self.scheduler.add_job(\n            self.run_cleanup,\n            'cron',\n            hour=3,\n            minute=0,\n            id='daily_cleanup',\n            replace_existing=True  # 重启时替换已有任务\n        )\n        \n        self.scheduler.start()\n        logger.info(\"Cleanup scheduler started\")\n    \n    async def run_cleanup(self) -> int:\n        \"\"\"执行 90 天清理\"\"\"\n        # 实现略...\n        pass\n    \n    def shutdown(self):\n        if self.scheduler:\n            self.scheduler.shutdown(wait=True)\n```\n\n#### 备选方案：外部 Cron（推荐多实例部署）\n\n如果部署多个 Worker 实例，建议使用外部 Cron 代替 APScheduler：\n\n```bash\n# /etc/cron.d/picturetranslate-cleanup\n# 每天凌晨 3:00 执行，通过 API 触发（需认证）\n0 3 * * * curl -X POST http://localhost:8000/api/internal/cleanup \\\n  -H \"X-Internal-Token: ${CLEANUP_TOKEN}\" \\\n  >> /var/log/cleanup.log 2>&1\n```\n\n```python\n# api/routes/internal.py\n@router.post(\"/internal/cleanup\")\nasync def trigger_cleanup(x_internal_token: str = Header(...)):\n    if x_internal_token != settings.CLEANUP_TOKEN:\n        raise HTTPException(403, \"Invalid token\")\n    count = await cleanup_service.run_cleanup()\n    return {\"deleted\": count}\n```\n\n### Frontend Components\n\n#### 1. MaskCanvas (components/MaskCanvas.tsx)\n- **Purpose**: Mask 绘制画布\n- **Props**:\n  ```typescript\n  interface MaskCanvasProps {\n    imageUrl: string;\n    width: number;\n    height: number;\n    onMaskChange: (maskBlob: Blob, mimeType: string) -> void;\n    brushSize?: number;\n    tool?: 'brush' | 'eraser';\n  }\n  ```\n- **Features**: PointerEvents, WebP 压缩导出 + PNG 回退\n\n#### MaskCanvas 导出实现（WebP 优先 + PNG 回退）\n\n```typescript\n// components/MaskCanvas.tsx\nconst exportMask = async (canvas: HTMLCanvasElement): Promise<{blob: Blob, mimeType: string}> => {\n  // 检测 WebP 支持\n  const supportsWebP = await checkWebPSupport();\n  \n  return new Promise((resolve, reject) => {\n    if (supportsWebP) {\n      // 优先使用 WebP（压缩率更高）\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            resolve({ blob, mimeType: 'image/webp' });\n          } else {\n            // WebP 失败，回退到 PNG\n            fallbackToPNG(canvas, resolve, reject);\n          }\n        },\n        'image/webp',\n        0.8  // 80% 质量\n      );\n    } else {\n      // 不支持 WebP，使用 PNG\n      fallbackToPNG(canvas, resolve, reject);\n    }\n  });\n};\n\nconst fallbackToPNG = (\n  canvas: HTMLCanvasElement,\n  resolve: (value: {blob: Blob, mimeType: string}) => void,\n  reject: (reason: Error) => void\n) => {\n  canvas.toBlob(\n    (blob) => {\n      if (blob) {\n        resolve({ blob, mimeType: 'image/png' });\n      } else {\n        reject(new Error('Failed to export mask'));\n      }\n    },\n    'image/png'\n  );\n};\n\n// WebP 支持检测（缓存结果）\nlet webPSupported: boolean | null = null;\nconst checkWebPSupport = async (): Promise<boolean> => {\n  if (webPSupported !== null) return webPSupported;\n  \n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      webPSupported = img.width === 1;\n      resolve(webPSupported);\n    };\n    img.onerror = () => {\n      webPSupported = false;\n      resolve(false);\n    };\n    img.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA=';\n  });\n};\n\n// 使用示例\nconst handleMaskComplete = async () => {\n  const { blob, mimeType } = await exportMask(canvasRef.current);\n  onMaskChange(blob, mimeType);\n};\n```\n\n#### 2. TextEditor (components/TextEditor.tsx)\n- **Purpose**: 文字图层编辑\n- **Props**:\n  ```typescript\n  interface TextEditorProps {\n    layers: TextLayer[];\n    onLayerUpdate: (id: string, updates: Partial<TextLayer>) => void;\n    selectedLayerId?: string;\n  }\n  ```\n\n#### 3. useJobQueue (hooks/useJobQueue.ts)\n- **Purpose**: 批量任务状态管理\n- **Returns**:\n  ```typescript\n  {\n    jobs: Job[];\n    createJob: (files: File[], params: TranslateParams) => Promise<string>;\n    subscribeProgress: (jobId: string) => void;\n    cancelJob: (jobId: string) => void;\n  }\n  ```\n\n## Data Models\n\n### SQLite 连接池配置 (core/database.py)\n\n```python\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.orm import sessionmaker\nfrom contextlib import contextmanager\n\n# 连接池配置：SQLite + WAL 模式\nDATABASE_URL = \"sqlite:///./data/translations.db\"\n\nengine = create_engine(\n    DATABASE_URL,\n    connect_args={\n        \"check_same_thread\": False,  # 允许多线程\n        \"timeout\": 30,               # busy_timeout: 30秒等待锁\n    },\n    pool_size=5,                     # 连接池大小\n    max_overflow=10,                 # 最大溢出连接\n    pool_pre_ping=True,              # 连接健康检查\n)\n\n# 启用 WAL 模式（并发读优化）\n@event.listens_for(engine, \"connect\")\ndef set_sqlite_pragma(dbapi_connection, connection_record):\n    cursor = dbapi_connection.cursor()\n    cursor.execute(\"PRAGMA journal_mode=WAL\")\n    cursor.execute(\"PRAGMA busy_timeout=30000\")  # 30秒\n    cursor.execute(\"PRAGMA synchronous=NORMAL\")  # 平衡性能与安全\n    cursor.close()\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n@contextmanager\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\n\n### Job (SQLite: jobs)\n```sql\nCREATE TABLE jobs (\n  id TEXT PRIMARY KEY,\n  status TEXT CHECK(status IN ('pending','processing','done','failed')),\n  images_count INTEGER,\n  completed_count INTEGER DEFAULT 0,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\nCREATE INDEX idx_jobs_status ON jobs(status);\n```\n\n### Translation (SQLite: translations)\n```sql\nCREATE TABLE translations (\n  id TEXT PRIMARY KEY,            -- UUID\n  job_id TEXT REFERENCES jobs(id),\n  image_uuid TEXT NOT NULL,       -- 图片独立 UUID，用于存储路径\n  original_path TEXT,\n  mask_path TEXT,\n  result_path TEXT,\n  source_lang TEXT,\n  target_lang TEXT,\n  status TEXT CHECK(status IN ('pending','processing','done','failed')),\n  error_message TEXT,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\nCREATE INDEX idx_translations_job ON translations(job_id);\nCREATE INDEX idx_translations_status ON translations(status);\nCREATE INDEX idx_translations_created ON translations(created_at);\n```\n\n### 事务型任务拉取示例 (services/job_queue.py)\n\n```python\nfrom sqlalchemy import text\n\ndef pull_pending_translation(db) -> Optional[Translation]:\n    \"\"\"\n    事务型任务拉取：防止并发抢占\n    使用 SELECT ... FOR UPDATE 语义（SQLite 通过事务实现）\n    \"\"\"\n    with db.begin():  # 自动提交/回滚\n        # 查找并锁定一条 pending 记录\n        result = db.execute(\n            text(\"\"\"\n                UPDATE translations \n                SET status = 'processing', updated_at = CURRENT_TIMESTAMP\n                WHERE id = (\n                    SELECT id FROM translations \n                    WHERE status = 'pending' \n                    ORDER BY created_at ASC \n                    LIMIT 1\n                )\n                RETURNING *\n            \"\"\")\n        ).fetchone()\n        \n        if result:\n            return Translation(**result._mapping)\n        return None\n```\n\n### TextLayer (Frontend)\n```typescript\ninterface TextLayer {\n  id: string;\n  text: string;\n  x: number;\n  y: number;\n  fontSize: number;\n  fontFamily: string;\n  color: string;\n  rotation: number;\n}\n```\n\n## API Contract\n\n### POST /api/jobs\n创建批量翻译任务\n\n**Request:**\n```\nContent-Type: multipart/form-data\n\nfiles[]: File[] (1-5 张)\nmasks[]: File[] (可选，与 files 对应)\nsource_lang: string (default: \"en\")\ntarget_lang: string (default: \"zh\")\nprotect_product: boolean (default: true)\n```\n\n**Response (201):**\n```json\n{\n  \"job_id\": \"uuid-xxx\",\n  \"images_count\": 3,\n  \"status\": \"pending\",\n  \"sse_url\": \"/api/jobs/uuid-xxx/sse\"\n}\n```\n\n### GET /api/jobs/{id}/sse\nSSE 进度推送（EventSourceResponse + asyncio.Queue Pub/Sub）\n\n**Event Stream:**\n```\nevent: progress\ndata: {\"image_index\": 0, \"image_uuid\": \"uuid-xxx\", \"status\": \"processing\"}\n\nevent: progress\ndata: {\"image_index\": 0, \"image_uuid\": \"uuid-xxx\", \"status\": \"done\", \"result_url\": \"/storage/...\"}\n\nevent: complete\ndata: {\"job_id\": \"xxx\", \"completed\": 3, \"failed\": 0}\n\nevent: error\ndata: {\"image_index\": 1, \"image_uuid\": \"uuid-yyy\", \"error\": \"API rate limit\"}\n```\n\n#### SSE Manager 实现 (services/sse_manager.py)\n\n```python\nimport asyncio\nfrom typing import Dict, Set\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass SSEEvent:\n    event: str\n    data: dict\n\nclass SSEManager:\n    \"\"\"\n    Pub/Sub 模式的 SSE 事件管理器\n    - 每个 job_id 对应一组订阅者队列\n    - Worker 完成翻译后 publish 事件\n    - SSE 端点 subscribe 获取事件流\n    \"\"\"\n    def __init__(self):\n        self._subscribers: Dict[str, Set[asyncio.Queue]] = {}\n        self._lock = asyncio.Lock()\n    \n    async def subscribe(self, job_id: str) -> asyncio.Queue:\n        \"\"\"订阅任务进度\"\"\"\n        queue = asyncio.Queue()\n        async with self._lock:\n            if job_id not in self._subscribers:\n                self._subscribers[job_id] = set()\n            self._subscribers[job_id].add(queue)\n        return queue\n    \n    async def unsubscribe(self, job_id: str, queue: asyncio.Queue):\n        \"\"\"取消订阅\"\"\"\n        async with self._lock:\n            if job_id in self._subscribers:\n                self._subscribers[job_id].discard(queue)\n                if not self._subscribers[job_id]:\n                    del self._subscribers[job_id]\n    \n    async def publish(self, job_id: str, event: SSEEvent):\n        \"\"\"发布事件到所有订阅者\"\"\"\n        async with self._lock:\n            subscribers = self._subscribers.get(job_id, set()).copy()\n        for queue in subscribers:\n            await queue.put(event)\n\n# 全局单例\nsse_manager = SSEManager()\n```\n\n#### SSE 路由实现 (api/routes/jobs.py)\n\n```python\nfrom sse_starlette.sse import EventSourceResponse\nfrom services.sse_manager import sse_manager, SSEEvent\n\n@router.get(\"/jobs/{job_id}/sse\")\nasync def job_progress_sse(job_id: str):\n    \"\"\"SSE 端点：实时推送任务进度\"\"\"\n    async def event_generator():\n        queue = await sse_manager.subscribe(job_id)\n        try:\n            while True:\n                event = await asyncio.wait_for(queue.get(), timeout=30.0)\n                yield {\n                    \"event\": event.event,\n                    \"data\": json.dumps(event.data)\n                }\n                if event.event == \"complete\":\n                    break\n        except asyncio.TimeoutError:\n            yield {\"event\": \"ping\", \"data\": \"{}\"}\n        finally:\n            await sse_manager.unsubscribe(job_id, queue)\n    \n    return EventSourceResponse(event_generator())\n```\n\n#### Worker 发布事件示例\n\n```python\n# services/translator.py\nasync def process_translation(translation: Translation, sse_manager: SSEManager):\n    job_id = translation.job_id\n    \n    # 开始处理\n    await sse_manager.publish(job_id, SSEEvent(\n        event=\"progress\",\n        data={\"image_uuid\": translation.image_uuid, \"status\": \"processing\"}\n    ))\n    \n    try:\n        result = await translate_image(...)\n        await sse_manager.publish(job_id, SSEEvent(\n            event=\"progress\",\n            data={\n                \"image_uuid\": translation.image_uuid,\n                \"status\": \"done\",\n                \"result_url\": result.url\n            }\n        ))\n    except Exception as e:\n        await sse_manager.publish(job_id, SSEEvent(\n            event=\"error\",\n            data={\"image_uuid\": translation.image_uuid, \"error\": str(e)}\n        ))\n```\n\n### GET /api/history\n历史记录列表\n\n**Query Params:**\n- page: int (default: 1)\n- limit: int (default: 20)\n- source_lang: string (可选)\n- target_lang: string (可选)\n- date_from: string (可选)\n- date_to: string (可选)\n\n**Response:**\n```json\n{\n  \"items\": [\n    {\n      \"id\": \"xxx\",\n      \"thumbnail_url\": \"/storage/.../thumb.jpg\",\n      \"source_lang\": \"en\",\n      \"target_lang\": \"zh\",\n      \"created_at\": \"2024-12-04T10:00:00Z\"\n    }\n  ],\n  \"total\": 100,\n  \"page\": 1,\n  \"pages\": 5\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **批量超限 (>5张)**\n   - HTTP 400: `{\"error\": \"BATCH_LIMIT\", \"message\": \"最多同时上传5张图片\"}`\n\n2. **任务不存在**\n   - HTTP 404: `{\"error\": \"JOB_NOT_FOUND\", \"message\": \"任务不存在\"}`\n\n3. **Aliyun API 限流**\n   - 内部重试 3 次，指数退避\n   - 最终失败: 标记 translation.status = 'failed'\n\n4. **存储空间不足**\n   - HTTP 500: `{\"error\": \"STORAGE_ERROR\", \"message\": \"存储空间不足\"}`\n   - Sentry 告警\n\n### Sentry Integration\n\n#### FastAPI 后端初始化 (core/sentry.py)\n\n```python\nimport sentry_sdk\nfrom sentry_sdk.integrations.fastapi import FastApiIntegration\nfrom sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration\nfrom sentry_sdk.integrations.logging import LoggingIntegration\nimport logging\n\ndef init_sentry(dsn: str, environment: str):\n    \"\"\"\n    在 FastAPI lifespan 中初始化 Sentry\n    - 集成 FastAPI 异常捕获\n    - 集成 SQLAlchemy 查询追踪\n    - 集成 logging 错误上报\n    \"\"\"\n    sentry_sdk.init(\n        dsn=dsn,\n        integrations=[\n            FastApiIntegration(transaction_style=\"endpoint\"),\n            SqlalchemyIntegration(),\n            LoggingIntegration(\n                level=logging.INFO,\n                event_level=logging.ERROR  # ERROR 及以上上报\n            ),\n        ],\n        traces_sample_rate=0.1,  # 10% 性能采样\n        profiles_sample_rate=0.1,\n        environment=environment,\n        send_default_pii=False,  # 不发送 PII 数据\n    )\n```\n\n#### FastAPI Lifespan 集成 (api/main.py)\n\n```python\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom core.sentry import init_sentry\nfrom core.config import settings\nfrom services.cleanup import cleanup_service\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    if settings.SENTRY_DSN:\n        init_sentry(settings.SENTRY_DSN, settings.ENVIRONMENT)\n    \n    cleanup_service.schedule_cleanup()\n    \n    yield\n    \n    # Shutdown\n    cleanup_service.shutdown()\n\napp = FastAPI(lifespan=lifespan)\n```\n\n#### React 前端初始化 (frontend/src/sentry.ts)\n\n```typescript\nimport * as Sentry from \"@sentry/react\";\n\nexport function initSentry() {\n  // 从环境变量获取 DSN（Vite 构建时注入）\n  const dsn = import.meta.env.VITE_SENTRY_DSN;\n  \n  if (!dsn) {\n    console.warn(\"Sentry DSN not configured\");\n    return;\n  }\n  \n  Sentry.init({\n    dsn,\n    environment: import.meta.env.MODE,\n    integrations: [\n      Sentry.browserTracingIntegration(),\n      Sentry.replayIntegration({\n        maskAllText: true,\n        blockAllMedia: true,\n      }),\n    ],\n    tracesSampleRate: 0.1,\n    replaysSessionSampleRate: 0.1,\n    replaysOnErrorSampleRate: 1.0,\n  });\n}\n```\n\n#### React 入口文件 (frontend/src/main.tsx)\n\n```typescript\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport * as Sentry from \"@sentry/react\";\nimport { initSentry } from \"./sentry\";\nimport App from \"./App\";\n\n// 初始化 Sentry\ninitSentry();\n\nReactDOM.createRoot(document.getElementById(\"root\")!).render(\n  <React.StrictMode>\n    <Sentry.ErrorBoundary fallback={<ErrorFallback />}>\n      <App />\n    </Sentry.ErrorBoundary>\n  </React.StrictMode>\n);\n\nfunction ErrorFallback() {\n  return (\n    <div className=\"min-h-screen flex items-center justify-center\">\n      <div className=\"text-center\">\n        <h1 className=\"text-2xl font-bold text-red-600\">出错了</h1>\n        <p className=\"text-gray-600 mt-2\">请刷新页面重试</p>\n        <button \n          onClick={() => window.location.reload()}\n          className=\"mt-4 px-4 py-2 bg-blue-500 text-white rounded\"\n        >\n          刷新页面\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n#### Vite 环境变量配置\n\n```bash\n# .env.production\nVITE_SENTRY_DSN=https://xxx@sentry.io/xxx\nVITE_API_BASE_URL=https://api.farmaxbeauty.shop\n```\n\n## Mobile Responsive Strategy\n\n### Breakpoints (Tailwind)\n```css\n/* Mobile: < 768px */\n/* Tablet: 768px - 1024px */\n/* Desktop: > 1024px */\n```\n\n### Component Visibility\n| 组件 | Mobile | Tablet | Desktop |\n|------|--------|--------|---------|\n| Dashboard 上传 | 单图 | 批量 | 批量 |\n| MaskCanvas | 隐藏 | 显示 | 显示 |\n| TextEditor | 隐藏 | 简化 | 完整 |\n| Split View | 纵向 | 横向 | 横向 |\n| History | 列表 | 卡片 | 卡片 |\n\n### Mobile-Specific UI\n```tsx\n// Dashboard.tsx\nconst isMobile = useMediaQuery('(max-width: 768px)');\n\nreturn isMobile ? (\n  <MobileUpload onUpload={handleSingleUpload} />\n) : (\n  <BatchUpload onUpload={handleBatchUpload} maxFiles={5} />\n);\n```\n\n## Performance Optimization\n\n### Backend\n- **ThreadPoolExecutor**: max_workers=6\n- **SQLite WAL**: 并发读优化\n- **LRU Cache**: hash(original+mask+params) 为 key\n- **指数退避**: Aliyun API 重试\n\n### Frontend\n- **Mask 压缩**: WebP 0.8 quality, < 500KB\n- **图片懒加载**: Intersection Observer\n- **Canvas 性能**: requestAnimationFrame\n- **字体预加载**: `<link rel=\"preload\" href=\"/fonts/...\">`\n\n## Backup Strategy\n\n### Daily Backup (cron 3:00 AM)\n```bash\n#!/bin/bash\n# backup.sh\nDATE=$(date +%Y%m%d)\nsqlite3 /app/data/translations.db \".backup /app/backups/db-$DATE.sqlite\"\nrclone sync /app/storage r2:picturetranslate/storage --max-age 7d\nfind /app/backups -name \"*.sqlite\" -mtime +7 -delete\n```\n\n### Dokploy Volume\n```yaml\nvolumes:\n  - ./data:/app/data        # SQLite\n  - ./storage:/app/storage  # 图片文件\n  - ./backups:/app/backups  # 备份\n```\n\n## Testing Strategy\n\n### Unit Testing\n- services/job_queue.py: 状态流转测试\n- services/storage.py: 文件操作测试\n- utils/: 工具函数测试\n\n### Integration Testing\n- API 端点测试 (pytest + httpx)\n- SSE 流测试\n- 数据库事务测试\n\n### E2E Testing (可选)\n- 批量上传 → 进度 → 下载流程\n- 移动端响应式测试\n\n## Risk Assessment\n\n| 风险 | 等级 | 缓解措施 | Codex 审查状态 |\n|------|------|----------|----------------|\n| SQLite 写锁竞争 | 中→低 | WAL 模式 + SQLAlchemy 连接池 + busy_timeout 30s + 事务型任务拉取 | ✅ 已解决 |\n| SSE 轮询性能 | 中→低 | EventSourceResponse + asyncio.Queue Pub/Sub（非数据库轮询） | ✅ 已解决 |\n| 批量存储冲突 | 中→低 | `storage/{job_id}/{image_uuid}/...` 结构 + 数据库 UUID 追踪 | ✅ 已解决 |\n| Mask 兼容性 | 低 | 前端 WebP 优先 + PNG 回退 + 后端 MIME 校验转码 | ✅ 已解决 |\n| APScheduler 多实例 | 中→低 | SQLite JobStore + coalesce + misfire_grace_time 或外部 Cron | ✅ 已解决 |\n| Sentry 初始化时机 | 低 | FastAPI lifespan 初始化 + React @sentry/react ErrorBoundary | ✅ 已解决 |\n| 大批量请求积压 | 中 | 队列 + 5 张限制 | - |\n| 存储空间增长 | 中 | 90 天清理 + R2 备份 | - |\n| Aliyun API 不稳定 | 高 | 重试 + Sentry 告警 | - |\n\n## Decision Log\n\n- **2024-12-04**: 选择方案 A（轻量级 SQLite 全栈）\n- **2024-12-04 v2.0 Codex 审查修订**:\n  - **SQLite**: 增加 SQLAlchemy 连接池、WAL 模式、busy_timeout、事务型任务拉取示例\n  - **SSE**: 从数据库轮询改为 EventSourceResponse + asyncio.Queue Pub/Sub\n  - **存储**: 从 `{job_id}/original.png` 改为 `{job_id}/{image_uuid}/...` 支持批量\n  - **Mask**: 增加前端 WebP 检测 + PNG 回退，后端 MIME 校验与转码\n  - **APScheduler**: 增加 SQLite JobStore、coalesce、misfire_grace_time 配置，提供外部 Cron 备选\n  - **Sentry**: 增加 FastAPI lifespan 初始化、React @sentry/react 集成示例\n- **队列方案**: SQLite 状态机（非 Redis，减少依赖）\n- **存储方案**: 文件系统 + 路径入库（非 BLOB）\n- **进度推送**: SSE + Pub/Sub（非 WebSocket，更简单）\n- **Mask 格式**: WebP 优先 + PNG 回退（跨浏览器兼容）\n",
  "fileStats": {
    "size": 33517,
    "lines": 1002,
    "lastModified": "2025-12-04T09:06:46.275Z"
  },
  "comments": []
}